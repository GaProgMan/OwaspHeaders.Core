// Note:  some commments (especially those which explain what the different
//        parameters for each header) are taken from the OWASP Secure Headers
//        page. The original comments can be found at:
//                https://www.owasp.org/index.php/OWASP_Secure_Headers_Project
// Note:  the description of the Expect-CT header (used above the UseExpectCt
//        method) is taken from the MDN page for the header, which can be found
//        at the following url:
//          https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT

using static OwaspHeaders.Core.Models.CrossOriginResourcePolicy;

namespace OwaspHeaders.Core.Extensions;

public static class SecureHeadersMiddlewareBuilder
{
    private static SecureHeadersMiddlewareConfiguration Config => new();

    public static SecureHeadersMiddlewareConfiguration CreateBuilder()
    {
        return Config;
    }

    /// <summary>
    /// Includes the HTTP Strict Transport Security header in all responses
    /// generated by the application which consumes this middleware
    /// </summary>
    /// <param name="maxAge">
    /// The The time, in seconds, that the browser should remember that this
    /// site is only to be accessed using HTTPS
    /// </param>
    /// <param name="includeSubDomains">
    /// If this optional parameter is specified, this rule applies to all of
    /// the site's subdomains as well
    /// </param>
    /// <remarks>
    /// If no values for <param name="maxAge"/> or <param name="includeSubDomains"/>
    /// are provided, then default ones will be used. These default values will be
    /// based on the OWASP best practises values for HSTS.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseHsts
    (this SecureHeadersMiddlewareConfiguration config,
        int maxAge = 31536000, bool includeSubDomains = true)
    {
        config.UseHsts = true;
        config.HstsConfiguration = new HstsConfiguration(maxAge, includeSubDomains);

        return config;
    }

    /// <summary>
    /// Declares a policy communicated from a host to the client browser on whether
    /// the browser must not display the transmitted content in frames of other web pages
    /// </summary>
    /// <param name="xFrameOption">
    /// Whether or not we should allow rendering this site within a frame.
    /// Applicable values are: deny; sameorigin; and allowfrom
    /// </param>
    /// <param name="domain">
    /// If allowfrom is supplied, this optional parameter describes the domain in which
    /// our site is permitted to be loaded within a frame 
    /// </param>
    /// <remarks>
    /// If no value for <param name="xFrameOption"/> is rovided, then default one will be
    /// used. This default value is based on the OWASP best practises value for X-Frame-Options.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseXFrameOptions
    (this SecureHeadersMiddlewareConfiguration config,
        XFrameOptions xFrameOption = XFrameOptions.Deny,
        string domain = null)
    {
        config.UseXFrameOptions = true;
        config.XFrameOptionsConfiguration = new XFrameOptionsConfiguration(xFrameOption, domain);

        return config;
    }

    /// <summary>
    /// Enables the Cross Site Scripting protection filter in the client browser.
    /// </summary>
    /// <remarks>
    /// This overload will use the X-XSS-Protection value of 0. This effectively disables
    /// the XSS Auditor, and is required for modern browsers. Please ensure that you have
    /// a value Content-Security Policy enabled, otherwise you are opening yourself up to
    /// a world of trouble.
    /// The XSS Auditor needs to be disabled because it can lead to client-side security
    /// issues in modern browsers.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseXssProtection
        (this SecureHeadersMiddlewareConfiguration config)
    {
        config.UseXssProtection = true;
        config.XssConfiguration = new XssConfiguration();
        return config;
    }

    /// <summary>
    /// Setting this header will prevent the browser from interpreting files as something
    /// else than declared by the content type in the HTTP headers
    /// </summary>
    /// <remarks>
    /// There is no value to pass in here, OWASP recommends that if you use this header
    /// (X-ContentType-Options), then the value of "nosniff" be used. "nosniff" is the default
    /// value for this header when using this middleware class.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseContentTypeOptions
        (this SecureHeadersMiddlewareConfiguration config)
    {
        config.UseXContentTypeOptions = true;

        return config;
    }

    /// <summary>
    /// CSP prevents a wide range of attacks, including Cross-site scripting and other
    /// cross-site injections.
    /// </summary>
    /// <remarks>
    /// This method sets up a CSP header with:
    ///  - all mixed content blocked
    ///  - all insecure
    ///  - requests upgraded to HTTPS
    ///  - a ScriptSrc of "self"
    ///  - an ObjectSrc of "self"
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseDefaultContentSecurityPolicy
        (this SecureHeadersMiddlewareConfiguration config)
    {
        config.UseContentSecurityPolicy = true;

        config.ContentSecurityPolicyConfiguration = new ContentSecurityPolicyConfiguration
            (null, true, true, null, null);

        config.SetCspUris(
            [ContentSecurityPolicyHelpers.CreateSelfDirective()],
            CspUriType.Script);

        config.SetCspUris(
            [ContentSecurityPolicyHelpers.CreateSelfDirective()],
            CspUriType.Object);

        return config;
    }

    /// <summary>
    /// CSP prevents a wide range of attacks, including Cross-site scripting and other
    /// cross-site injections.
    /// </summary>
    /// <param name="pluginTypes">
    /// The set of plugins that can be invoked by the protected resource by limiting the
    /// types of resources that can be embedded
    /// </param>
    /// <param name="blockAllMixedContent">
    /// Prevent user agent from loading mixed content.
    /// </param>
    /// <param name="upgradeInsecureRequests">
    /// Instructs user agent to download insecure resources using HTTPS.
    /// </param>
    /// <param name="reportUri">
    /// Specifies a URI to which the user agent sends reports about policy violation.
    /// </param>
    /// <param name="useXContentSecurityPolicy">
    /// Specifies if we should use X-Content-Security-Policy header as well for compatibility with Internet Explorer.
    /// </param>
    /// <remarks>
    /// Requires consumer to set up their own Content Security Policy Rules via calls to
    /// SetCspUris, which is an extension method on the <see cref="SecureHeadersMiddlewareConfiguration"/> object
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseContentSecurityPolicy
    (this SecureHeadersMiddlewareConfiguration config,
        string pluginTypes = null, bool blockAllMixedContent = true,
        bool upgradeInsecureRequests = true, string referrer = null,
        string reportUri = null, bool useXContentSecurityPolicy = false)
    {
        config.UseContentSecurityPolicy = true;
        config.UseXContentSecurityPolicy = useXContentSecurityPolicy;

        config.ContentSecurityPolicyConfiguration = new ContentSecurityPolicyConfiguration
            (pluginTypes, blockAllMixedContent, upgradeInsecureRequests, referrer, reportUri);

        return config;
    }

    public static SecureHeadersMiddlewareConfiguration UseContentSecurityPolicyReportOnly
    (this SecureHeadersMiddlewareConfiguration config, string reportUri,
        string pluginTypes = null, bool blockAllMixedContent = true,
        bool upgradeInsecureRequests = true, string referrer = null, bool useXContentSecurityPolicy = false)
    {
        // Check whether the URI is valid before continuing
        HeaderValueGuardClauses.StringCannotBeNullOrWhitsSpace(reportUri, nameof(reportUri));

        config.UseContentSecurityPolicyReportOnly = true;
        config.UseXContentSecurityPolicy = useXContentSecurityPolicy;

        config.ContentSecurityPolicyReportOnlyConfiguration = new ContentSecurityPolicyReportOnlyConfiguration
            (pluginTypes, blockAllMixedContent, upgradeInsecureRequests, referrer, reportUri);

        return config;
    }

    /// <summary>
    /// A cross-domain policy grants a web client permission to handle data across domains
    /// </summary>
    /// <remarks>
    /// If a <see cref="XPermittedCrossDomainOptionValue"/> is not supplied, then the default value of "none" will
    /// be used
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UsePermittedCrossDomainPolicies
    (this SecureHeadersMiddlewareConfiguration config,
        XPermittedCrossDomainOptionValue xPermittedCrossDomainOptionValue =
            XPermittedCrossDomainOptionValue.none)
    {
        config.UsePermittedCrossDomainPolicy = true;

        config.PermittedCrossDomainPolicyConfiguration =
            new PermittedCrossDomainPolicyConfiguration(xPermittedCrossDomainOptionValue);

        return config;
    }

    /// <summary>
    /// Governs which referrer information, sent in the Referer header, should be included with requests made
    /// </summary>
    /// <remarks>
    /// If a <see cref="ReferrerPolicyOptions"/> value is not supplied, then the default value of "no-referrer"
    /// will be used.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseReferrerPolicy
    (this SecureHeadersMiddlewareConfiguration config,
        ReferrerPolicyOptions referrerPolicyOption =
            ReferrerPolicyOptions.noReferrer)
    {
        config.UseReferrerPolicy = true;

        config.ReferrerPolicy = new ReferrerPolicy(referrerPolicyOption);
        return config;
    }

    /// <summary>
    /// The server did not return or returned an invalid 'Cache-Control' header which means page
    /// containing sensitive information (password, credit card, personal data, social security 
    /// number, etc) could be stored on client side disk and then be exposed to unauthorised persons. 
    /// This URL is flagged as a specific example.
    /// </summary>
    /// <param name="private">
    /// [OPTIONAL]
    /// Whether all or part of the HTTP response message is intended for a single user and must 
    /// not be cached by a shared cache.
    /// </param>
    /// <param name="maxAge">
    /// [OPTIONAL]
    /// The maximum age, specified in seconds, that the HTTP client is willing to accept a response.
    /// </param>
    /// <exception cref="ArgumentException">
    /// An ArgumentException is thrown when no Report URI is supplied 
    /// </exception>
    public static SecureHeadersMiddlewareConfiguration UseCacheControl
    (this SecureHeadersMiddlewareConfiguration config,
        bool @private = false, int maxAge = 0, bool noCache = false, bool noStore = true,
        bool mustRevalidate = false)
    {
        config.UseCacheControl = true;
        config.CacheControl = new CacheControl(@private, maxAge, noCache, noStore, mustRevalidate);
        return config;
    }

    /// <summary>
    /// Governs whether the site can opt-into reporting or enforcement of certificate
    /// transparency requirements, which prevents the use of mis-issued certificates
    /// for that site from going unnoticed
    /// </summary>
    /// <param name="reportUri">
    /// [REQUIRED]
    /// Specifies the URI to which the user agent should report Expect-CT failures.
    /// </param>
    /// <param name="maxAge">
    /// [REQUIRED, HAS DEFAULT]
    /// Specifies the number of seconds after reception of the Expect-CT header field
    /// during which the user agent should regard the host from whom the message was
    /// received as a known Expect-CT host
    /// </param>
    /// <param name="enforce">
    /// [OPTIONAL]
    /// Signals to the user agent that compliance with the Certificate Transparency
    /// policy should be enforced (rather than only reporting compliance) and that the
    /// user agent should refuse future connections that violate its Certificate
    /// Transparency policy.
    /// </param>
    /// <exception cref="ArgumentException">
    /// An ArgumentException is thrown when no Report URI is supplied 
    /// </exception>
    public static SecureHeadersMiddlewareConfiguration UseExpectCt
    (this SecureHeadersMiddlewareConfiguration config,
        string reportUri, int maxAge = 86400, bool enforce = false)
    {
        config.UseExpectCt = true;
        config.ExpectCt = new ExpectCt(reportUri, maxAge, enforce);
        return config;
    }

    /// <summary>
    /// The HTTP Cross-Origin-Resource-Policy response header conveys a desire that the browser 
    /// blocks no-cors cross-origin/cross-site requests to the given resource.
    /// </summary>
    /// <param name="value">
    /// The HTTP Cross-Origin-Resource-Policy response header value.
    /// </param>
    /// <remarks>
    /// Defaults to "same-origin" (<see cref="CrossOriginResourceOptions.SameOrigin"/>) which means
    /// that "Only requests from the same Origin (i.e. scheme + host + port) can read the resource."
    ///</remarks>
    public static SecureHeadersMiddlewareConfiguration UseCrossOriginResourcePolicy(
        this SecureHeadersMiddlewareConfiguration config,
        CrossOriginResourceOptions value = CrossOriginResourceOptions.SameOrigin)
    {
        config.UseCrossOriginResourcePolicy = true;
        config.CrossOriginResourcePolicy = new CrossOriginResourcePolicy(value);
        return config;
    }

    /// <summary>
    /// The HTTP Cross-Origin-Opener-Policy (COOP) response header allows a website to control
    /// whether a new top-level document, opened using Window.open() or by navigating to a new
    /// page, is opened in the same browsing context group (BCG) or in a new browsing context group.
    /// Source: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy
    /// </summary>
    /// <param name="value">
    /// The HTTP Cross-Origin-Opener-Policy response header value.
    /// </param>
    /// <remarks>
    /// Defaults to "same-origin" (<see cref="CrossOriginOpenerPolicy.CrossOriginOpenerOptions.SameOrigin"/>)
    /// which means that "Only requests from the same Origin (i.e. scheme + host + port) can read the resource."
    ///</remarks>
    public static SecureHeadersMiddlewareConfiguration UseCrossOriginOpenerPolicy(
        this SecureHeadersMiddlewareConfiguration config,
        CrossOriginOpenerPolicy.CrossOriginOpenerOptions value =
            CrossOriginOpenerPolicy.CrossOriginOpenerOptions.SameOrigin)
    {
        config.UseCrossOriginOpenerPolicy = true;
        config.CrossOriginOpenerPolicy = new CrossOriginOpenerPolicy(value);
        return config;
    }

    /// <summary>
    /// The HTTP Cross-Origin-Embedder-Policy (COEP) response header configures embedding
    /// cross-origin resources into the document.
    /// Source: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy
    /// </summary>
    /// <param name="value">
    /// The HTTP Cross-Origin-Embedder-Policy response header value.
    /// </param>
    /// <remarks>
    /// Defaults to "require-corp" (<see cref="CrossOriginEmbedderPolicy.CrossOriginEmbedderOptions.RequireCorp"/>)
    /// which means that "Only requests from the same Origin (i.e. scheme + host + port) can read the resource."
    ///</remarks>
    public static SecureHeadersMiddlewareConfiguration UseCrossOriginEmbedderPolicy(
        this SecureHeadersMiddlewareConfiguration config,
        CrossOriginEmbedderPolicy.CrossOriginEmbedderOptions value =
            CrossOriginEmbedderPolicy.CrossOriginEmbedderOptions.RequireCorp)
    {
        config.UseCrossOriginEmbedderPolicy = true;
        config.CrossOriginEmbedderPolicy = new CrossOriginEmbedderPolicy(value);
        return config;
    }

    /// <summary>
    /// Used to set a list of URLs that we want the middleware to NOT operate on
    /// </summary>
    /// <param name="config"></param>
    /// <param name="urlsToIgnore">
    /// A list of URLs that we the middleware to not operate on
    /// </param>
    /// <returns></returns>
    public static SecureHeadersMiddlewareConfiguration SetUrlsToIgnore(
        this SecureHeadersMiddlewareConfiguration config,
        List<string> urlsToIgnore = null)
    {
        if (urlsToIgnore != null)
        {
            config.UrlsToIgnore = urlsToIgnore;
        }
        return config;
    }

    /// <summary>
    /// Configures custom event IDs for logging to avoid conflicts with application event IDs
    /// </summary>
    /// <param name="config">The configuration instance</param>
    /// <param name="loggingConfig">Custom logging configuration with specific event IDs</param>
    /// <returns>The configuration instance for method chaining</returns>
    public static SecureHeadersMiddlewareConfiguration WithLoggingEventIds(
        this SecureHeadersMiddlewareConfiguration config,
        SecureHeadersLoggingConfiguration loggingConfig)
    {
        ObjectGuardClauses.ObjectCannotBeNull(loggingConfig, nameof(loggingConfig),
            "cannot be null when configuring logging event IDs");

        config.LoggingConfiguration = loggingConfig;
        return config;
    }

    /// <summary>
    /// Configures event IDs using a base offset to avoid conflicts with application event IDs.
    /// This creates event IDs starting from the base (e.g., baseEventId=5000 creates 5001, 5002, etc.)
    /// </summary>
    /// <param name="config">The configuration instance</param>
    /// <param name="baseEventId">Base event ID to offset from (recommended: use multiples of 1000)</param>
    /// <returns>The configuration instance for method chaining</returns>
    /// <example>
    /// <code>
    /// var config = SecureHeadersMiddlewareBuilder
    ///     .CreateBuilder()
    ///     .UseHsts()
    ///     .WithLoggingEventIdBase(5000) // Creates event IDs 5001, 5002, etc.
    ///     .Build();
    /// </code>
    /// </example>
    public static SecureHeadersMiddlewareConfiguration WithLoggingEventIdBase(
        this SecureHeadersMiddlewareConfiguration config,
        int baseEventId)
    {
        config.LoggingConfiguration = SecureHeadersLoggingConfiguration.CreateWithBaseEventId(baseEventId);
        return config;
    }

    /// <summary>
    /// Enables the Clear-Site-Data header for all responses with OWASP recommended defaults
    /// </summary>
    /// <param name="config">The configuration instance</param>
    /// <param name="directiveOptions">The directive options to include (defaults to cache, cookies, storage)</param>
    /// <returns>The configuration instance for method chaining</returns>
    /// <remarks>
    /// This enables Clear-Site-Data for all responses. For path-specific configuration,
    /// use <see cref="UseClearSiteDataForPaths"/> or <see cref="AddClearSiteDataPath"/> instead.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseClearSiteData(
        this SecureHeadersMiddlewareConfiguration config,
        params ClearSiteDataOptions[] directiveOptions)
    {
        // Use OWASP recommended defaults if no options provided
        if (directiveOptions.Length == 0)
        {
            directiveOptions = [ClearSiteDataOptions.cache, ClearSiteDataOptions.cookies, ClearSiteDataOptions.storage];
        }

        config.UseClearSiteData = true;

        var clearSiteDataConfig = new ClearSiteDataConfiguration(directiveOptions);
        var pathConfig = new Dictionary<string, ClearSiteDataConfiguration>();

        config.ClearSiteDataPathConfiguration = new ClearSiteDataPathConfiguration(
            pathConfig, clearSiteDataConfig);

        return config;
    }

    /// <summary>
    /// Configures path-specific Clear-Site-Data header behavior
    /// </summary>
    /// <param name="config">The configuration instance</param>
    /// <param name="pathConfigurations">Dictionary mapping paths to their Clear-Site-Data directive options</param>
    /// <param name="defaultConfiguration">Default directives for non-matching paths (optional)</param>
    /// <returns>The configuration instance for method chaining</returns>
    /// <remarks>
    /// Only the specified paths will receive Clear-Site-Data headers unless a default configuration is provided.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration UseClearSiteDataForPaths(
        this SecureHeadersMiddlewareConfiguration config,
        Dictionary<string, ClearSiteDataOptions[]> pathConfigurations,
        ClearSiteDataOptions[] defaultConfiguration = null)
    {
        ObjectGuardClauses.ObjectCannotBeNull(pathConfigurations, nameof(pathConfigurations),
            $"{nameof(pathConfigurations)} cannot be null");

        config.UseClearSiteData = true;

        var configuredPaths = new Dictionary<string, ClearSiteDataConfiguration>();
        foreach (var kvp in pathConfigurations)
        {
            configuredPaths[kvp.Key] = new ClearSiteDataConfiguration(kvp.Value);
        }

        ClearSiteDataConfiguration defaultConfig = null;
        if (defaultConfiguration != null && defaultConfiguration.Length > 0)
        {
            defaultConfig = new ClearSiteDataConfiguration(defaultConfiguration);
        }

        config.ClearSiteDataPathConfiguration = new ClearSiteDataPathConfiguration(
            configuredPaths, defaultConfig);

        return config;
    }

    /// <summary>
    /// Adds a path-specific Clear-Site-Data configuration
    /// </summary>
    /// <param name="config">The configuration instance</param>
    /// <param name="path">The path to configure</param>
    /// <param name="directiveOptions">The directive options for this path</param>
    /// <returns>The configuration instance for method chaining</returns>
    /// <remarks>
    /// This method can be called multiple times to configure different paths.
    /// Use this for fluent path-by-path configuration.
    /// </remarks>
    public static SecureHeadersMiddlewareConfiguration AddClearSiteDataPath(
        this SecureHeadersMiddlewareConfiguration config,
        string path,
        params ClearSiteDataOptions[] directiveOptions)
    {
        HeaderValueGuardClauses.StringCannotBeNullOrWhitsSpace(path, nameof(path));
        ObjectGuardClauses.ObjectCannotBeNull(directiveOptions, nameof(directiveOptions),
            $"{nameof(directiveOptions)} cannot be null");

        if (directiveOptions.Length == 0)
        {
            ArgumentExceptionHelper.RaiseException(nameof(directiveOptions));
        }

        config.UseClearSiteData = true;

        // Initialize if not already configured
        if (config.ClearSiteDataPathConfiguration == null)
        {
            var initialPaths = new Dictionary<string, ClearSiteDataConfiguration>();
            config.ClearSiteDataPathConfiguration = new ClearSiteDataPathConfiguration(initialPaths);
        }

        // Create new configuration with the additional path
        var existingPaths = new Dictionary<string, ClearSiteDataConfiguration>();
        foreach (var kvp in config.ClearSiteDataPathConfiguration.PathConfigurations)
        {
            existingPaths[kvp.Key] = kvp.Value;
        }

        existingPaths[path] = new ClearSiteDataConfiguration(directiveOptions);

        config.ClearSiteDataPathConfiguration = new ClearSiteDataPathConfiguration(
            existingPaths, config.ClearSiteDataPathConfiguration.DefaultConfiguration);

        return config;
    }

    /// <summary>
    /// Return the completed <see cref="SecureHeadersMiddlewareConfiguration"/> ready for consumption by the
    /// <see cref="SecureHeadersMiddleware"/> class
    /// </summary>
    public static SecureHeadersMiddlewareConfiguration Build
        (this SecureHeadersMiddlewareConfiguration config)
    {
        return config;
    }
}
